#! /bin/bash

##/*! \file qaConfiguration.h
## \brief Parse configuration given by file or command-line

## Priority: command-line statements overwrite all previous
## settings. If a <<t>> -f conf-file<</tt>> and <<t>> -t task-file <</t>>
## are available, then statements in the task-file overrules
## the conf-file. Task-files and config-file are formatted equivalently.\n \n
## Syntax of statements in a configuration file.
## Note: Default values in []\n
## SYNTAX: key[[+]=value[,value[,value,\newline ...]] \n
## -# There are key-words, assignments, comments. Key-words are always
## uppercase. Assignments of multiple values may be given as
## comma-separated lists. A comment is everything following the '#'
## character. Empty lines, and spaces are discarded.
## Notice that the spelling of key-words is not checked. Assignments may
## be anything. Unknown key-words (or typos) are ignored. Significant
## spaces (I hope there are none for CMIP5) have to be escaped by '\'.
## BUT, #this is not implemented. Will be done only on request!
## -# Assignment to a key-word is given by: key-word=value.
## -# Enabling/disabling features is done by assigning t/f to a
## key-word.
## A pure key-word on a text line defaults to true [t]
## e.g. ARITHMETIC_MEAN is equivalent to ARITHMETIC_MEAN=t.
## Disabling by assigning 'f' is equivalent to commenting out.
## -# Multiple line assignments. Multiple assignments must have
## key-word += value. Omittion of '+' overwrites previous assignments.\n
## -# SELECT/LOCK has a special syntax (with [] indicating optional):\n
## SELECT [path1[, path2, ...] = ] [var1[, var2, ...]]\n
## Note: '=' has a special meaning for SELECT; mulitple assignments just add.
## Same for LOCK.
##*/

# ##//! Default setting for some key-words.

setDefaults()
{
  definedProjects=( CORDEX CMIP5 CMIP6 )

  # the comment 'export' denotes keywords which must be submitted
  # to the calling qaDirector

  # you should not leave this unchanged in the config file
  test ! ${QA_RESULTS} && setKWL QA_RESULTS=./QA_Results
  test ! ${PROJECT_DATA} && setKWL PROJECT_DATA=./

  setKWL QA_HOST=$HOSTNAME

  setKWL QA_BIN=${HOSTNAME}:${QA_SRC}/bin

  # A list of machines executing asynchronous jobs.
  setKWL QA_EXEC_HOSTS=$HOSTNAME

  # If a process cannot be run, because e.g. the data base
  # is not available or a server is absent, then, after a
  # sleep, retry. But only for the number of times spefied below.
  setKWL REATTEMPT_LIMIT=5 # export

  # In order to enable trapping signals, long sleeping period are
  # subdivided into smaller intervals of consecutive sleep commands.
  setKWL HARD_SLEEP_PERIOD=10        # [s] export

  # if not there then 'mail' will be set after a successful check
  setKWL MAIL=mailx

# List of number(s) of simultaneous entity of executors per host.
# This is a friendly act against your colleagues.
# Special: the one and only number is assigned to all QA_EXEC_HOSTS.
# Fine tuning: each positional number in the list corresponds to a
# position in the QA_EXEC_HOSTS list. If less positions are given
# than in QA_EXEC_HOSTS, then the last position is assigned to
# the omitted positions.
  setKWL NUM_EXEC_THREADS=1

  setKWL SLEEP_PERIOD=300            # [s] export
}


changeGroupPermission()
{
  local sendText

  # Give permissions to all group members
  if [ ${GROUP_NAME} ] ; then
    # change to new group name
    item=$( ls -ld $1 | awk '{print $4}' )
    if [ "$item" != "$GROUP_NAME" ] ; then
      if ! chgrp -R $GROUP_NAME $1 &> /dev/null ; then
        std_out "${0##*/}::changeGroupPermission(): chgrp "
        std_out "Invalid group or you are probably not allowed to change group."
        std_out "If so, please ask your admin to chgrp -R $GROUP_NAME $1"
        std_out flush
        exit 1
      fi
    fi

    # set SGID bit
    item=$( ls -ld $1 | awk '{print $1}' )
    if [ ! "${#sendText}" -a ${item:6:1} != s ] ; then
      # It would be amazing if chmod would not be allowed, but chgrp was
      find $1 -type d -exec chmod g+srwx {} \;
      find $1 -type f -exec $QA_SRC/scripts/cpMod {} \;
    fi
  fi
}

##//! Check availabillity of tools.

checkTools()
{
  local sendText  # failed checks will accumulate text
  local isExit=f;
  local str

  # check only tools, display, and exit
  CHECK_TOOLS=${CHECK_TOOLS:-f}

  # we know that it's bash

  if [ $CHECK_TOOLS = t ] ; then
    if [ ! -e $QA_SRC ] ; then
      std_out "$QA_SRC\t\t directory not found"
    else
      std_out "QA_SRC\t\t $QA_SRC"
    fi
  fi

  if [ ! -x ${QA_SRC}/bin/qA-${PROJECT_AS}.x ] ; then
    if [ qA-${PROJECT_AS}.x = qA-install.x ] ; then
      std_out "PROJECT name not available. See qa-dkrz --help for option '--install'"
#    else
#      std_out "Executable ${QA_SRC}/bin/qA-${PROJECT_AS}.x not available."
#      std_out "Please, run: ${QA_SRC}/install with ${PROJECT} or PROJECT_AS name"
    isExit=t ;
    fi
  fi

  # all machines must share the same file system

  # invoke execution paths
  local bin l nnn
  for(( l=0 ; l < ${#QA_BIN[*]} ; ++l )) ; do
    bin=${QA_BIN[l]}
    bin=${bin%/}  # rm trailing '/'
    if ! mkdir -p ${bin#*:} &> /dev/null ; then
       std_out "Fatal error: could not mkdir ${bin#*:}"
    fi

    # valid on the qa-DKRZ host
    if [ "${bin#*:}" = "${bin}" ] ; then
      PATH=${bin}:$PATH  # this is 'imported' by qa-DKRZ
    elif [ "${bin%:*}" = "${HOSTNAME}" ] ; then
      PATH=${bin#*:}:$PATH  # this is 'imported' by qa-DKRZ
    fi
  done

  # test initial existance of some basic commands

  if [ ${CHECKSUM} ] ; then
    local cs
    if [ ${CHECKSUM} = t ] ; then
      cs=md5
    else
      cs=${CHECKSUM%sum}
    fi

    if [ ! -x $cs ] ; then
      if tryExist com ${cs}sum ; then
         test $CHECK_TOOLS = t && std_out "${cs}sum\t\t available"
      else
         str="${cs}sum\t\t not found; switch to md5sum."
         test $CHECK_TOOLS = t && std_out "$str"
         CHECKSUM=md5
      fi
    fi
  fi

  if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
    # try mailx
    if tryExist com ${MAIL} void ; then
      test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
    else
      MAIL=mail
      if tryExist com ${MAIL}  ; then
        test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
      else
        EMAIL_TO=
        str="${MAIL}(x)\t\t not found; email notification disabled"
        test $CHECK_TOOLS = t && std_out "$str"
      fi
    fi
  fi

  # a few simple commands: exclude bc ssh
  # below: awk expt
  local cmd
  for cmd in basename 'date +\'%F%T'' \
             git grep kill ls mkdir mv sed rm sleep test
  do
    if tryExist com $cmd ; then
      test $CHECK_TOOLS = t && std_out "${cmd}\t\t available"
    else
      isExit=t ;
      std_out "command: ${cmd}\t\t not available"
    fi
  done

  if  which awk &> /dev/null || which gawk &> /dev/null ; then
     test $CHECK_TOOLS = t && std_out "(g)awk\t\t available"
  else
     isExit=t ;
     std_out "(g)awk\t\t not available"
  fi

  if which expr &> /dev/null ; then
     if expr match asdf234 '.*f\([[:digit:]]*\)' &> /dev/null ; then
       test $CHECK_TOOLS = t && std_out "expr\t\t available"
     else
       sendText="${sendText}\nexpr match asdf234 \'.*f\([[:digit:]]*\)\': no"
       isExit=t ;
       std_out "expr\t\t available, but not working"
     fi
  else
     isExit=t ;
     std_out "expr\t\t not available"
  fi

  # no email notification
  test ${CHECK_TOOLS} = t && exit 1

  if [ ${isExit} = t ] ; then
    std_out flush
    exit 1
  fi
}

##//! Description of usage on the terminal

##/*!
## In case of --help or invalid command-line argument.
##*/

findProject()
{
  # Scan files for explicit PROJECT and PROJECT_AS specifications.

  # find valid project names used in table
  if [ ${#definedProjects[*]} -eq 0 ] ; then
    definedProjects=( $( ls ${QA_SRC}/tables/projects) )
    definedProjects=( ${definedProjects[*]} $( ls ${QA_SRC}/tables) )

    local i
    for(( i=0 ; i < ${#definedProjects[*]} ; ++i )) ; do
      if [ ${definedProjects[i]} = projects ] ; then
         unset definedProjects[i]
         definedProjects=( ${definedProjects[*]} )
         break
      fi
    done
  fi

  # look for a specification in the current conf-files.
  local val

  if [ ! ${PROJECT} ] ; then
    val=( $(grep "^[[:space:]]*[^#]*[[:space:]]*PROJECT=" $1 ) )
    if [ "${val}" ] ; then
      setKWL PROJECT=${val#*=}
    fi
  fi

  if [ ! ${PROJECT_AS} ] ; then
    val=( $(grep "^[[:space:]]*[^#][[:space:]]*PROJECT_AS=" $1 ) )
    if [ "${val}" ] ; then
      setKWL PROJECT_AS=${val#*=}
    fi
  fi

  if [ ! ${PROJECT} ] ; then
    local item names name
    names=( QA_CONF QC_CONF qa_conf qc_conf )

    for name in ${names[*]} ; do
      val=( $(grep "^[[:space:]]*[^#][[:space:]]*${name}=" $1 ) )
      if [ "${val}" ] ; then
        val=${val#*=}
        val=${val%_qa.conf}
        val=${val%_qc.conf}

        for(( i=0 ; i < ${#definedProjects[*]} ; ++i )) ; do
          if [ ${definedProjects[i]} = ${val} ] ; then
             setKWL PROJECT=$val
             setKWL PROJECT_AS=$val
             return
          fi
        done

        break
      fi
    done
  fi

  return
}

findStr()
{
  test ${DEBUG_CONF} && voidX

  # find position of sub-string in string
  # $1: the string
  # $2: sub-string to find
  # $3: 'return' the position, if $3 exists

  local i
  local len=${#2}
  local end=$(( ${#1} - len + 1 ))

  for(( i=0 ; i < end ; ++i )) ; do
    if [ "${1:i:len}" = "$2" ] ; then
      test ${#3} -gt 0 && eval ${3}=$i
      test ${DEBUG_CONF} && voidX
      return 0
    fi
  done

  test ${DEBUG_CONF} && voidX
  return 1
}

getMultiLists()
{
  # note that a CF_check-list.conf file may be given in every project.
  # The rules given within would overwrite default CF ones.

  local prjList cfList
  declare -a prjList cfList

  for qacf in ${QA_CONFS//,/ } ; do
     qa_cl=( ${qa_cl[*]} $(grep "^[[:space:]]*[^#][[:space:]]*QA_CHECK_LIST=" $qacf ) )
  done

  # precedence of check lists: user-defined --> default
  local fs=( CF_check-list.conf ${qa_cl[*]#*=} \
             ${PROJECT}_check-list.conf \
             ${PROJECT_AS}_check-list.conf )

  local ff i p pL
  for p in ${pDir[*]} ; do
    test -f $p/${fs[0]} && cfList[${#cfList[*]}]=$p/${fs[0]}

    # distinguish between user-defined, PROJECT and PROJECT_AS
    for(( i=1 ; i < ${#fs[*]} ; ++i )) ; do
      ff=${fs[i]}

      for pL in ${prjList[*]} ; do
         test ${pL} = $p/$ff && continue 2
      done

      test -f $p/${ff} && prjList[${#prjList[*]}]=$p/${ff}
    done
  done

  p=${QA_HOME}/tables/projects/CF
  test -f $p/${fs[0]} && cfList[${#cfList[*]}]=$p/${fs[0]}

  if [ $# -gt 0 ] ; then
    # notes provided on the command-line;
    # there are two types possible: one for CF the other for the project

    set +B # disable brace expansion
    local a arg cf_CL prj_CL isCF isPRJ
    declare -a cf_CL prj_CL

    for arg in $* ; do
      if findStr ${arg} CF_ ; then
        if [ ${isCF:-f} = f  ] ; then
          local cl_CF_note=/tmp/CF_comLineNote_$$.txt
          isCF=t
        fi

        # multiple notes could be given aus comma-sep-braces;
        # print each note on a separate line of the file
        arg="${arg#*=}"
        arg=( ${arg//\},/\} } )
        for a in ${arg[*]} ; do
          echo "text & ${a}" >> /tmp/CF_comLineNote_$$.txt
        done
      else
        if [ ${isPRJ:-f} = f  ] ; then
          local cl_PRJ_note=/tmp/PRJ_comLineNote_$$.txt
          isPRJ=t
        fi

        # multiple notes could be given aus comma-sep-braces;
        # print each note on a separate line of the file
        arg="${arg#*=}"
        arg=( ${arg//\},/\} } )
        for a in ${arg[*]} ; do
          echo "text & ${a}" >> /tmp/PRJ_comLineNote_$$.txt
        done
      fi
    done

    set -B
  fi

  local cf="${cl_CF_note}${cl_CF_note:+ }${cfList[*]}"
  local prj="${cl_PRJ_note}${cl_PRJ_note:+ }${prjList[*]}"

  setKWL CF_CHECK_LIST="${cf// /,}"
  setKWL QA_CHECK_LIST="${prj// /,}"

  return
}

findQAConfSeq()
{
  qaConfFileSeq=( $* )

  # the first two items of array 'task_priority' would have been
  # set while performing getops().

  local i item qaResults

  # resolve relative paths
  for(( i=0 ; i < ${#qaConfFileSeq[*]} ; ++i )) ; do
    if [ ${qaConfFileSeq[i1]:0:2} = './' ] ; then
      qaConfFileSeq[i]=${qaConfFileSeq[i]:2}
    elif [ ${qaConfFileSeq[i]:0:3} = '../' ] ; then
      item=$(pwd)
      item=${item%/*}
      qaConfFileSeq[i]=${item}/${qaConfFileSeq[i]:3}
    fi

    findProject ${qaConfFileSeq[i]}
  done

  if [ ${PROJECT} ] ; then
     test ! ${PROJECT_AS} && PROJECT_AS=$PROJECT
  elif [ ${isExample:-f} = f ] ; then
     return
  fi

  # paths to files to be concatenated; highest priority for the first one.
  # When PROJECT_AS and PROJECT are set differently, then PROJECT is derived
  # from PROJECT_AS and gets higher priority of the two. Note that in such a case,
  # there is no default setting for PROJECT, but only for PROJECT_AS. Configuration
  # options pointing to files must begin with PROJECT or PROJECT_AS, respectively,
  # followed by '_'.
  pDir[0]=$(pwd)  # local path
  pDir[${#pDir[*]}]=${QA_HOME}/tables
  if [ ${#PROJECT} -gt 0 -a "${PROJECT}" != "${PROJECT_AS}" ] ; then
    pDir[${#pDir[*]}]=${QA_HOME}/tables/${PROJECT}
  else
    pDir[${#pDir[*]}]=${QA_HOME}/tables/${PROJECT_AS}
  fi
  pDir[${#pDir[*]}]=${QA_HOME}/tables/projects/${PROJECT_AS}


  # This loop only works for filenames passed as parameters.
  # Go through the chain of files unless no more
  # is found or a path found before is found again;
  # an invalid file would also break processing
  local fs

  for(( i=0 ; i < ${#pDir[*]} ; ++i )) ; do
    if ! fs=( $(ls ${pDir[i]}/*_qa.conf 2> /dev/null) ) ;then
      fs=( $(ls ${pDir[i]}/*_qc.conf 2> /dev/null) )
    fi

    test ${#fs[*]} -gt 0 && \
      qaConfFileSeq[${#qaConfFileSeq[*]}]=${fs[0]}
  done


  return
}



initSession()
{
  # Create sub-dir structure for different logs, but
  # the check_logs. md5sum checksums of conf and task
  # (all may be omitted and substituted by '-') are written to a file.
  # Specific command-line options (SHOW_*)
  # will write 'test_session', i.e. set RESUME_SESSION=f.
  # A session is definded by conf and task files given
  # in array QA_CONF.
  # When all checkums of the current files are found in a previous session,
  # then the latter is resumed, i.e. RESUME_SESSION=t.
  # Explicit RESUME_SESSION=f disables.

  # base path to sessions
  if [ ! "${LOG_FNAMES}" ] ; then
    test ! -d ${QA_RESULTS}/session_logs && mkdir -p ${QA_RESULTS}/session_logs
  fi

  setKWL RESUME_SESSION=t  # by default

  # force a new session, although resuming would be possible
  test ${FORCE_NEW_SESSION:-f} = t && setKWL RESUME_SESSION=f

  # find test-cases from command-line options
  local i j cl testCase

  for(( i=0 ; i < ${#comLine[*]} ; ++i )) ; do
    cl=${comLine[i]}

    test ${cl:0:7} = '-E_SHOW'  \
        && setKWL RESUME_SESSION=f \
            && break
  done

  # current checksums; note: md5sum ouputs two items: checksum and filename
  # (filename is substituted by '-' for reading from input)
  local curr_md5
  declare -a curr_md5
  local currDate=$( date +'%F_%T' )

  local qaC qaCs
  qaCs=( ${QA_CONFS[*]//,/ } )

  if [ ${#qaCs[*]} -gt 0 ] ; then
    for qaC in ${qaCs[*]}  ; do
      curr_md5=( ${curr_md5[*]} $( md5sum $qaC | awk '{print $1}') )
    done
  else
    curr_md5=( '-' )
  fi

  # test for resuming a session
  if [ ${RESUME_SESSION} = t ] ; then
    local k l sDates
    local dates0 dates1
    declare -a dates0 dates1

    # look for a previous identical session given in file sess_md5.txt
    if [ -f ${QA_RESULTS}/session_logs/sess_md5.txt ] ; then
      # first item is a date, second is a checksum.
      dates0=( $(grep "${curr_md5[0]}" \
                ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                | awk '{print $1}' ) )

      for(( k=1 ; k < ${#qaCs[*]} ; ++k )) ; do
        dates1=( $(grep "${curr_md5[k]}" \
                 ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                 |  awk '{print $1}' ) )

        for(( i=${#dates0[*]}-1 ; i >-1 ; --i )) ; do
          for(( j=0 ; j < ${#dates1[*]} ; ++j )) ; do
            # compare to the date of another conf/task file
            if [ ${dates0[i]} = ${dates1[j]} ] ; then
              continue 2
            fi
          done
          unset dates0[${i}]
        done
      done

      dates0=( ${dates0[*]} )  # remove empty items

      if [ ${#dates0[*]} -eq 1 ] ; then
        setKWL SESSION=${dates0[0]}
      else
        local is=t
        for(( j=1 ; j < ${#dates0[*]} ; ++j )) ; do
          test ${dates0[0]} != ${dates0[j]} && is=f
        done
        test $is = f -o ${#dates0[*]} -eq 0 && setKWL RESUME_SESSION=f
      fi
    else
      setKWL RESUME_SESSION=f
    fi
  else
    if [ ${testCase:-f} = t ] ; then
      setKWL SESSION=test_session
      test -d ${QA_RESULTS}/session_logs/test_session && \
         \rm -r ${QA_RESULTS}/session_logs/test_session
    fi

    setKWL RESUME_SESSION=f
  fi

  # session date wasn't set externally.
  if [ ! "${LOG_FNAMES}" ] ; then
    if [ ${RESUME_SESSION} = f -a ${testCase:-f} = f ] ; then
      for(( k=0 ; k < ${#qaCs[*]} ; ++k )) ; do
        # write a new entry for each conf/task file
        echo -e -n "${currDate}\t" \
               >> ${QA_RESULTS}/session_logs/sess_md5.txt
        echo -e -n "${curr_md5[k]}\t" \
               >> ${QA_RESULTS}/session_logs/sess_md5.txt
        echo       "${qaCs[k]}" \
               >> ${QA_RESULTS}/session_logs/sess_md5.txt
      done

      setKWL SESSION=${currDate}
    fi
  fi

  setKWL SESSION_LOGDIR=${QA_RESULTS}/session_logs/${SESSION}
  test ! "${LOG_FNAMES}" && mkdir -p ${SESSION_LOGDIR}

  return
}

loadSetting()
{
  local tmp

  if [ ! ${QA_SRC} ] ; then
    sendSubject='QA: initialisation error'
    std_out "QA_SRC must be set. Exit."
    std_out flush
    exit 1
  fi

  if [ ! -d "$QA_SRC" ] ; then
    sendSubject='QA: initialisation error'
    std_out "Source dir $QA_SRC must exist and must be writable. Exit."
    std_out flush
    exit 1
  fi

  tmp=(${PROJECT_DATA[*]//,/ })
  tmp=(${tmp[*]%/})  # rm trailing '/'

  # completion of relative paths
  for(( i=0 ; i < ${#tmp[*]} ; ++i )) do
    test ${tmp[i]:0:1} = '/' && continue

    if [ ${tmp[i]:0:1} = '.'  ] ; then
      tmp[${i}]=$(pwd)${tmp[i]:1}
    elif [ ${tmp[i]:0:2} = '..'  ] ; then
      myPwd=$(pwd)
      tmp[${i}]=${myPwd%/*}${tmp[i]:2}
    else
      tmp[${i}]=$(pwd)/${tmp[i]}
    fi
  done

  tmp="${tmp[*]}"
  PROJECT_DATA=${tmp// /,}

  QA_SRC=${QA_SRC%/}  # rm trailing '/'

  QA_RESULTS=${QA_RESULTS%/}  # rm trailing '/'
  if [ ${QA_RESULTS:0:1} != '/' ] ; then
    if [ ${QA_RESULTS:0:2} = './'  ] ; then
      QA_RESULTS=$(pwd)${QA_RESULTS:1}
    elif [ ${QA_RESULTS:0:3} = '../'  ] ; then
      myPwd=$(pwd)
      QA_RESULTS=${myPwd%/*}${QA_RESULTS:2}
    else
      QA_RESULTS=$(pwd)/${QA_RESULTS}
    fi
  fi

  for pD in ${PROJECT_DATA[*]//,/ } ; do
    if [ ! -d "$pD" ] ; then
      std_out "PROJECT_DATA: $pD not found"
      std_out flush
      exit 1
    fi

    if [ "$pD" = "$QA_RESULTS" ] ; then
      # this must not happen
      sendSubject='QA: configuration error'
      std_out "Conflict: QA_RESULTS and PROJECT_DATA are identical. Exit."
      std_out flush
      exit 1
    fi

  done


  if [ ! ${PROJECT_DATA} ]  ; then
    local isRoot=t
    for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
      test ${pathList[i]:0:1} != '/' && isRoot=f && break
    done

    if [ ${isRoot} = t ] ; then
      # get it from SELECT with absolute path
      for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
        test ${PROJECT_DATA} && PROJECT_DATA="${PROJECT_DATA},"

        PROJECT_DATA="${PROJECT_DATA}${pathList[i]%/*}"
        pathList[i]=${pathList[i]##*/}
      done

      setKWL PROJECT_DATA=${PROJECT_DATA}
    else
      std_out "missing PROJECT_DATA assignment."
      std_out flush
      exit 1
    fi
  fi

  # Naming and placement of the base dirs in QA_RESULTS.
  # Inits also session-logs
  naming

  # change permissions
#  changeGroupPermission $QA_SRC
#  if [ "${QA_RESULTS:0:${#QA_WORK}}" != "$QA_WORK" ] ; then
#    changeGroupPermission $QA_RESULTS
#  fi

  # any error case happened before is written now
  if [ ${sendSubject} ] ; then
    std_out flush
    exit 1
  fi

  # check required directories, files and executables
  checkTools

  return
}

parseConfigurationFile()
{
  local confFile=$1

  local isBlockBeg=t
  local block

  if [ ${confFile} ] ; then
     if [ ! -e $confFile ] ; then
       return
     fi
  else
     return
  fi

  # now parse the configuration file.

  confLine=

  # Assignments from multiple lines infer their termination from
  # the next comment/blank line.
  # Reading lines happens in function parseLines (clear comments)

  # connect filename to input; keep it open for the while-loop
  exec 0< $confFile

  set -f

  while parseLines ; do
    if [ $isBlockBeg = t -a "${line}" ] ; then
      if findStr "$line" ':=' ; then
        # assignement of multi-line block.
        # Requires an empty or comment line underneath.
        isBlockBeg=f  # reset to true for a new- or comment-line
        line=${line/:=/=}
      fi

      block=
    fi

    # parsing for: key-word[=...]
    # find the key-word
    block=${block}${line}

    # read next line of a block
    test $isBlockBeg = f && continue

    # special: SELECT and LOCK syntax
    if [ "${block:0:6}" = 'LOCK+=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:5}" = 'LOCK=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:4}" = LOCK ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock L =${block:4}
       else
         sel_lock L +=${block:4}
       fi
       continue
    fi

    if [ "${block:0:8}" = 'SELECT+=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:7}" = 'SELECT=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:6}" = SELECT ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock S =${block:6}
       else
         sel_lock S +=${block:6}
       fi
       continue
    fi

    # assignment (blocks) are parsed
    parseKeyWordList
  done

  set +f
  # disconnect filename to input
  exec 0<&-

  return
}

naming()
{
  # A change in the placement of results.

  # QA_RESULTS will contain sub-dirs:
  # tables, data, check_logs,
  # and checksum; the latter only on request.
  # Sub-dir session_logs contains config, tasks, processing information.
  # As before, directory data/${PROJECT} will get the dir-tree spanned by
  # PROJECT_DATA=.*/project-name/dir-tree

  setKWL QA_RESULTS=$QA_RESULTS

  # the place for general log-messages
  initSession

  # sub-dir for experiment logs
  setKWL LOG_FNAME_DIR=${QA_RESULTS}/check_logs
  test ! "${LOG_FNAMES}"&& mkdir -p $LOG_FNAME_DIR

  if [ ! "${LOG_FNAMES}" ] ; then
    if ! mkdir -p ${QA_RESULTS}/data ; then
      sendSubject='QA: initialisation error'
      std_out "Could not mkdir ${QA_RESULTS}/data. Exit."
      std_out flush
      exit 1
     fi
  fi

  # determine the final table paths

  # project table
  if [ ! ${TABLE_PATH} ] ; then
    TABLE_PATH=${QA_RESULTS}/tables
    if [ ! "${LOG_FNAMES}" ] ; then
      test ! -d ${TABLE_PATH} && mkdir -p ${TABLE_PATH}
    fi
    setKWL TABLE_PATH=${TABLE_PATH}
  else
    # provided by configuration file
    # rm trailing '/'; does nothing, if such is not there
    TABLE_PATH=${TABLE_PATH%/}
  fi

  if [ ! -d "${TABLE_PATH}" -a ! "${LOG_FNAMES}" ] ; then
    std_out "Expecting a directory ${TABLE_PATH}. Please, check the configuration file."
    std_out flush
    exit 1
  fi
}

output()
{
  # Return the configuration and selected experiments
  # and parameters to the calling director.

  set -f

  # selection on the command-line cancels any selection in config-files
  if [ ${sl_args} ] ; then
    for(( i=0 ; i < ${#sl_args[*]} ; ++i )) ; do
      if [ ${sl_args[i]:0:1} = '/' ] ; then
        # rule: if absolute path on cmd-line, then cancel previous
        unsetKWL PROJECT_DATA

        pathList=
        varList=
      else
        if [ ${sl_args[i]/=/} = ${sl_args[i]} ] ; then
          # only variables; no path components
          for(( j=0 ; j < ${#pathList[*]} ; ++j )) ; do
            varList[j]=${sl_args[i]}
          done
          continue
        fi
      fi

      sel_lock S ${sl_args[i]}
    done
  fi

  # NOTE: arrays of experiments and parameters are provided
  #       by the file LOGIDR/cache_request_SESSION.txt

  # Synchronise QA_EXEC_HOSTS and NUM_EXEC_THREADS
  if [ ${#NUM_EXEC_THREADS[*]} -lt ${#QA_EXEC_HOSTS[*]} ] ; then
    myLastPos=$(( ${#NUM_EXEC_THREADS[*]} -1 ))
    myLastNum=${NUM_EXEC_THREADS[myLastPos]}
    for(( j=myLastPos+1 ; j < ${#QA_EXEC_HOSTS[*]} ; ++j )) ; do
      NUM_EXEC_THREADS[j]=$myLastNum
      # add key to the list
    done

    keyWordList[${#keyWordList[*]}]=NUM_EXEC_THREADS
  fi

  # sort and remove duplicates
  # Note: echo add a blank between items
  #       thus, the leading blank in the "" expression is required.
  keyWordList=( $(echo -e " ${keyWordList[*]/%/\\n}" | sort -b | uniq ) )

  test ${unset_PD:-f} = t && unsetKWL PROJECT_DATA

  # Prepare the settings as key=val, where val could also be an array.
  for key in ${keyWordList[*]} ; do
    test QA_DATA_ROOT = ${key} && continue
    test DATA_ROOT_FS = ${key} && continue
    test QA_PROJECT   = ${key} && continue

    eval val=( \${${key}[*]} )
    test ${val} &&  array[${#array[*]}]=${key}=${val[*]}
  done

  # remove duplicates
  pathList=( ${pathList[*]//,/ } )
  varList=( ${varList[*]//,/ } )
  for(( i=0 ; i < ${#pathList[*]} -1 ; ++i )) ; do
    for(( j=i+1 ; j < ${#pathList[*]} ; ++j )) ; do
      if [ "${varList[i]} = "${varList[j]} ] ; then
        if [ "${pathList[i]} = "${pathList[j]} ] ; then
          unset pathList[$j]
          unset varList[$j]
        fi
      fi
    done
  done
  pathList=( ${pathList[*]} )
  varList=( ${varList[*]} )

  # special treatmeant to preserve regExp
  if [ ${pathList} ] ; then
    array[${#array[*]}]=SELECT_PATH_LIST="${pathList[*]//,/ }"
    array[${#array[*]}]=SELECT_VAR_LIST="${varList[*]//,/ }"
  fi

  # special treatmeant to preserve regExp
  if [ ${lockPathList} ] ; then
    array[${#array[*]}]=LOCK_PATH_LIST="${lockPathList[*]//,/ }"
    array[${#array[*]}]=LOCK_VAR_LIST="${lockVarList[*]//,/ }"
  fi

  # display all assignments made
  if [ ${SHOW_CONF:-f} = t ] ; then
    for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
      std_out ${array[j]}
    done

    std_out flush
    test ${SHOW_EXP:-f} = f && exit 1
  fi

  # Submit the setting to the caller
  # It is necessary to change the field separator to keep embedded arrays distinct.
  IFS='%'

  for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
    echo -n "${array[j]}%"
  done

  std_out flush
}

parseKeyWordList()
{
   local key val tmp
   key=${block%%=*}

   if [ "$key" = "${block}" ] ; then
     val=
   else
     # Note: leading blanks have already been removed in parseLines()
     val="${block#*=}"   # remove ${key}=
   fi

   # compatibility
   if [ ${key} = IGNORE_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=ignore,${val/%,/}
   fi
   if [ ${key} = DISCARD_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=discard,${val/%,/}
   fi

   # allow RECORDS as well as RECORD (the latter will be used)
   pos=$(( ${#key} - 7 ))
   if [ "${key:pos}" = RECORDS ] ; then
     key=${key:0:$(( ${#key} -1 ))}
   fi

   # enable by just naming
   test ! ${val} && val=t

   setKWL ${key}="${val/%,/}"  # remove trailing ',', if present
   return
}

##//! Parse single lines of a configuration file

##/*!
## Discard comments and spaces.
##*/

parseLines()
{
  local line_
  local status
  unset line

  while : ; do
     # read a line
     read -r line_
     status=$?
     test ${status} -eq 1 -a ! "${line_}" && return 1

     # remove trailing comments from the line
     line_=$( expr match "$line_" '\([^#]*\)' )

     # in case of not empty, a non-comment-line was found
     test "${line_}" && break

     # reaching this indicates that a comment- or newline
     # was found

     if [ $isBlockBeg = f ] ; then
       # found the end of a block; process block
       isBlockBeg=t
       line=
       return 0
     fi
  done

  local i sz
  sz=${#line_}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${line_:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    line_="${line_//QC/QA}"
  else
    local tmp0="${line_:0:i}"
    tmp0="${tmp0//QC/QA}"
    line_="${tmp0}""${line_:i}"
  fi

  # we'd like to remember effective lines in the conf file
  confLine=${confLine}"${line_}"\\n

  # replace accidently used key-word: LOCKED or SELECTED
  test "$( echo -n "${line_:0:6}" \
     | tr [:lower:] [:upper:])" = "LOCKED" \
       && line_="LOCK${line_:6}"

  test "$( echo -n "${line_:0:8}" \
     | tr [:lower:] [:upper:])" = "SELECTED" \
       && line_="SELECT${line_:8}"

  # remove blanks from line
  line="${line_// /}"

  return 0
}

##//! Parse command-line options.

parseOPTARG()
{
  local key value

  key=${1%%=*}
  if [ "${1}" = "${1/=/}"  ] ; then
    value=t
  else
    value=${1#*=}
  fi

  if [ "${key}" = "ADD_PROG_ARG" ] ; then
    ADD_PROG_ARG=( ${ADD_PROG_ARG[*]} ${value} )
    keyWordList[${#keyWordList[*]}]=ADD_PROG_ARG
    return
  fi

  if [ "${key}" = "CHECK_TOOLS" ] ; then
    CHECK_TOOLS=t
    checkTools
    exit 1
  fi

  test "${key}" = CYCLE && \
    setKWL CYCLE=${value:-1} && return

  if [ "${key:0:7}" = DEBUG_C ] ; then
    set -x
    DEBUG_CONF=t
    return
  fi

  if [ "${key:0:7}" = DEBUG_M ] ; then
    setKWL DEBUG_MANAGER=${value:-t}
    return
  fi

  test "${key}" = SHOW_OPT && \
    displayComLineOptions 'dumb' && exit 1

  if [ "${key}" = NOTE ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        NOTE="${value}","${NOTE[*]// /,}"
        return
      fi
    done

  elif [ "${key}" = OUTLIER_TEST ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        if [ ${value} = f ] ; then
          OUTLIER_TEST=f
        else
          OUTLIER_TEST="${value}","${OUTLIER_TEST[*]// /,}"
        fi
        return
      fi
    done
  fi

  # no more syntax checks; invoke all
  setKWL ${key}=${value}

  return
}

##//! parse SELECT and LOCK assignments
sel_lock()
{
  # Note for SELECT, LOCK, -S and -L usage:
  # General setting:  {space, = ,+=}[path[=]][variable]

  # Examples:
  # leading character(s) supplied by the calling instances
  # -) '=' define or overwrite
  # -) '+=' prolong array of paths/variables
  # -) no leading '=' character equivalent to +=
  # -) not a path: variable(s) to path '.*', e.g. by -S var
  # -) contains '/', thus equivalent to 3)

  # 1) path=var
  #    specifies a single path where to look for a single variable
  # 2) p1,p2=var
  #    two paths to look for a variable
  # 3) p1,p2=
  #    two paths with every variable, equivalent to p1,p2=.*
  # 4) p1=v1,v2
  #    one path with two variables
  # 5) str1[,str2,str3]
  #    a) no '/' --> variables
  #    b) '/' anywhwere  --> only paths; no trapping of errors
  # 6) relative path without a '/' must have '=' appended
  # 7) p1=,p2=v1...  --> ERROR


  local i p v z

  # this is very special: a fully qualified file
  if [ -f $2 ] ; then
    z=${2%/*}=${2##*/}
  elif [ -f ${2:1} ] ; then
    z=${2%/*}=${2##*/}
  else
    z=$2
  fi

  while : ; do
    if [ ${z:0:1} = '=' ] ; then
      if [ $1 = S ] ; then
        pathList=
        varList=
      elif [ $1 = L ] ; then
        lockPathList=
        lockVarList=
      fi

      z="${z:1}"
    elif [ ${z:0:2} = '+=' ] ; then
      z=${z:2}
    elif [ ${z//=/} = ${z} -a ${z//\//} != ${z} ] ; then
#     z=${z}= # 7b), thus again
      break
    else
      if [ $1 = S ] ; then
        # only variable, no path
        if [ ${#pathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${pathList[$((${#pathList[*]} -1 ))]}=${z}"
          pathList=
          varList=
        fi
      elif [ $1 = L ] ; then
        if [ ${#lockPathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${lockPathList[$((${#lockPathList[*]} -1 ))]}=${z}"
          lockPathList=
          lockVarList=
        fi
      fi
    fi

    break;
  done;

  # now assignment mode is determined; parse on
  v=${z#*=}
  p=${z%=*}

  # no path, but only variable?
  if [ "$p" = "$v" ] ; then
    # test for a slash
    if [ "${p/\/}" = "${p}" ] ; then
      # no path; only variable
      p='.*'
    else
      v='.*'
    fi
  elif [ ${#p} -eq 0 -a ${#v} -gt 0 ] ; then
      # no path; only variable
      p='.*'
  elif [ ${#p} -gt 0 -a ${#v} -eq 0 ] ; then
      # no variable; only path
      v='.*'
  elif [ ${#v} -eq 0 ] ; then
    # there is only a path, but no explicit variable
    v='.*'
  fi

  # path and variable

  # multiple, comma-separated paths?
  local j pp vv
  pp=( ${p//,/ } )
  vv=( ${v//,/ } )
  p=()
  v=()

  for(( i=0 ; i < ${#pp[*]} ; ++i )) ; do
    for(( j=0 ; j < ${#vv[*]} ; ++j )) ; do
      p[${#p[*]}]=${pp[i]}
      v[${#v[*]}]=${vv[j]}
    done
  done

  # selection or a lock?
  if [ $1 = 'S' ] ; then
    pathList=( ${pathList[*]} ${p[*]} )
    varList=( ${varList[*]} ${v[*]} )
  elif [ $1 = 'L' ] ; then
    lockPathList=( ${lockPathList[*]} ${p[*]} )
    lockVarList=( ${lockVarList[*]} ${v[*]} )
  fi

  return
}

sendEMail()
{
  if [ ${#EMAIL_TO[*]} -eq 0 ] ; then
    sendText=
    sendSubject=
    return
  fi

  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s \"\$sendSubject\"  ${EMAIL_TO[*]} <<!
$sendText
!

  sendText=
  sendSubject=

  return
}

sendInitEMail()
{
  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s "$sendSubject"  ${EMAIL_TO[*]} <<!
$sendText

Configuration File Setting:
$( echo -e $confLine )

Command-line parameters:
$( echo "${comLine[*]}" )

Current Paths:
Source directory: $QA_SRC
QA data directory: $QA_RESULTS/data
FS data directory: ${PROJECT_DATA[*]}
!

  # this is required at some places
  sendText=
  sendSubject=

  return
}


##//! Convert assignment literals to Bash variables.

setKWL()
{
  test ${DEBUG_CONF} && voidX

  local key item value i val vals isAdd
  item="$*"

  for(( i=0 ; i < ${#item} ; ++i )) ; do
     if [ "${item:i:1}" = '+' ] ; then
        isAdd=t
        key="${item%%+=*}"

        break
     fi
     if [ "${item:i:1}" = '=' ] ; then
        isAdd=f
        key="${item%%=*}"
        break
     fi
  done

  key=$( echo "${key/% /}" | tr "[:lower:]" "[:upper:]" )
  if [ ${key} ] ; then
    value="${item#*=}"
  else
    key="${item#*=}"
    value=t
  fi

  # disable --> f
  test "${value:0:7}" = disable && value=f

  # backward compatibility
  if [ "${key::07}"   = DEBUG_E                    ] ; then
    key=DEBUG_EXECUTOR
  elif [ "${key}"     = EXP_FNAME_PATTERN          ] ; then
    key=LOG_FNAME_PATTERN
  elif [ "${key}"     = EXP_NAME                   ] ; then
    key=LOG_FNAME
  elif [ "${key}"     = EXP_PATH_BASE              ] ; then
    key=DRS_PATH_BASE
  elif [ "${key}"     = LOG_PATH_BASE              ] ; then
    key=DRS_PATH_BASE
  elif [ "${key}"     = EXP_PATH_INDEX             ] ; then
    key=LOG_PATH_INDEX
  elif [ "${key}"     = PT_PATH_INDEX             ] ; then
    key=CT_PATH_INDEX
  elif [ "${key}"     = HIDDEN_DIRECTORY_DESCENT   ] ; then
    key=HIDDEN_DIRECTORIES
  elif [ "${key}"     = NEXT -a "${value}" = t       ] ; then
    value=1
  elif [ "${key}"     = SHOW_EXP                   ] ; then
    key=SHOW_EXP
  elif [ "${key}"     = SHOW_NEXT -a "${value}" = t  ] ; then
    value=1
  elif [ "${key:0:7}" = SUMMARY                    ] ; then
    key=ONLY_SUMMARY
  fi

#  eval ${key}="${value// /\\ /}"

  # special: QA_BIN
  if [ "$key" = QA_BIN ] ; then
    value=${value%/}  # rm a trailing '/'
    vals=( ${value//,/ } )
    local host hosts
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
      val=${vals[i]}
      if [ "${val#*:}" = "${val}" ] ; then
        hosts[i]=''
      else
        hosts[i]="${val%:*}:"
      fi
      val=${val#*:}
      test "${val}" != "${vals[i]}" && vals[i]=${val}
    done

    # rearrange the array: the bin-dir of HOSTNAME is set
    # to the first position.
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
       if [ "${hosts[i]}" = "${HOSTNAME}:" \
                -o  ${#hosts[i]} -eq 0 ] ; then
         if [ $i -eq 0 ] ; then  # right order
           hosts[0]=''
           break
         fi

         local tmp
         tmp="${hosts[0]}"
         hosts[0]="${hosts[i]}"
         hosts[i]=$tmp

         tmp="${vals[0]}"
         vals[0]="${vals[i]}"
         vals[i]=$tmp

         break
       fi
    done

    QA_BIN=
    # convert relative paths to abolute ones
    test "${vals[0]:0:1}" != '/' && vals[0]=${QA_SRC}/${vals[0]}
    QA_BIN[0]=${vals[0]}

    for(( i=1 ; i < ${#vals[*]} ; ++i )) ; do
      # convert relative paths to abolute ones
      test "${vals[i]:0:1}" != '/' && vals[$i]=${QA_SRC}/${vals[i]}

      QA_BIN[${#QA_BIN[*]}]=${hosts[i]}${vals[i]}
    done
    value="${QA_BIN[*]}"
    value=${value// /,}
    unset QA_BIN

    # to be applied within this script
    curr_QA_BIN=${value%%,*}
  fi

  # was key already defined?
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      if [ $isAdd = f ] ; then
#        eval unset $key
        eval ${key}=${value}
      else
        tmp=${keyWordList[i]}
        eval $key=\${$tmp},${value// /\\ }
      fi

      test ${DEBUG_CONF} && voidX
      return 0
    fi
  done

  # new key
  eval ${key}="${value}"

  # add key to the list
  keyWordList[${#keyWordList[*]}]=$key

  test ${DEBUG_CONF} && voidX

  if [ ${ONLY_SUMMARY:-f} != f -a "${ONLY_SUMMARY}" != all ] ; then
    test ${ONLY_SUMMARY} != t && setKWL LOG_FNAMES=${ONLY_SUMMARY}
  fi

  return 0
}

std_out()
{
  # if a tty device is connected, then output immediately,
  # else collect contents and print to a default file and/or
  # send by email.

  test $# -eq 0 && return

  if [ "$1" = ttyOnly ] ; then
    if is_TTY ; then
       shift
       echo -e -n "$*" > $TTY
    fi
    return
  fi

  if [ "$1" = flush ] ; then
    local j str0

    test ${#outputText[*]} -eq 0 && return

    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        # each item begins with \n
        sendText="${sendText}\n${outputText[j]}"
      done
      if [ ! ${sendSubject} ] ; then
        sendSubject="qaConfiguration: message"
      fi
      sendEMail
    elif [ ! ${SESSION_LOGDIR} ] ; then
      str0="$( date +'%F %T' ) ${HOSTNAME%%.*}:qaConfiguration"
      echo -e "\n${str0}" >> $SESSION_LOGDIR/session.log

      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        echo -e "${outputText[j]}" >> $SESSION_LOGDIR/session.log
      done
    else
      # str0 gets the filename for undeliverables
      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
      if mkdir -p $QA_SRC/NoDevice &> /dev/null ; then
        for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
          echo -e "${outputText[j]}" >> $QA_SRC/NoDevice/$str0
        done
      fi
    fi
  else
    if [ -c "${TTY}" ] ; then # character device is open?
      echo -e "$*" > $TTY
    else
      outputText[${#outputText[*]}]="$*"
    fi
  fi
}

tryExist()
{
  test ${DEBUG_CONF} && voidX

  # if test fails, then something is written to sendText

  # $1:   'dir' | 'file' | 'com'
  # $2:    name of directory, file or command
  # $3:   key-word: 'compile' ; default: scan the path for the command.
  # $3:   key-word: 'void' ; return -1 without notification.

  #return 0 ==> exists
  #return 1 ==> no

  if [ "$1" = 'dir' ] ; then
    if [ ! -d $2 ] ; then
      sendText="${sendText}\nDirectory $1 not found."
      return 1
    fi

    test ${DEBUG_CONF} && voidX
    return 0
  fi

  if [ "$1" = 'file' ] ; then
    if [ ! -e $2 ] ; then
      sendText="${sendText}\nFile $1 not found."
      return 1
    fi

    test ${DEBUG_CONF} && voidX
    return 0
  fi

  if [ "$1" = 'com' ] ; then
    if which ${curr_QA_BIN#*:}/$2 &>/dev/null ; then
      return 0
    elif [ "$3" != 'compile' ] ; then
      if which $2 &>/dev/null ; then
        test ${DEBUG_CONF} && voidX
        return 0
      fi
      test "$3" != 'void' && \
         sendText="${sendText}\n command $2 not found."
      test ${DEBUG_CONF} && voidX
      return 1
    fi

    # try a C compilation
    if [ -e ${QA_SRC}/src/${2%.x}.c ] ; then
      if [ ! ${CC} ] ; then
        sendText="${sendText}\nC compiler not found."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      local answ status
      answ=$( $CC ${CFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.c )

      status=$?
      if [ ${status} -eq 0 ] ; then
        return 0
      else
        sendText="${sendText}\n${answ}"
        test ${DEBUG_CONF} && voidX
        return 1
      fi

    # try a C++ compilation
    elif [ -e ${QA_SRC}/src/${2%.x}.cpp ] ; then
      if [ ! ${CXX} ] ; then
        sendText="${sendText}\nC++ compiler not found CXX=${CXX}."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      local answ status
      answ=$( $CXX ${CPPFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.cpp &> /dev/null )

      status=$?
      if [ ${status} -eq 0 ] ; then
        test ${DEBUG_CONF} && voidX
        return 0
      else
        sendText="${sendText}\n${answ}"
        test ${DEBUG_CONF} && voidX
        return 1
      fi
    else
      if [ ! -e ${curr_QA_BIN#:*}/$2 ] ; then
        sendText="${sendText}\n${2%.x}.c|cpp not found in ${QA_SRC}/src."
        sendText="${sendText} No compilation."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      test ${DEBUG_CONF} && voidX
      return 0  # ok
    fi

    std_out 'qaConfiguration:tryExist() we never shall arrive here'
    std_out flush
    exit 1
  fi

  test ${DEBUG_CONF} && voidX
  return
}

tr_option()
{
  test ${DEBUG_CONF} && voidX

  local line="${!1}"

  if [ "${2}" ] ; then
    if [ ${#2} -eq 2 -a ${2:0:1} = '-' ] ; then
       # $2 indicates that this is the value of a ordinary option
       # in this case a value not of the form key=val is considered a value.
       local isOO=t
    fi
  fi

  local i pref
  for(( i=0 ; i < ${#line} ; ++i )) ; do
    if [ ${line:i:1} != - ] ; then
      line=${line:i}
      break
    else
      pref="${pref}-"
    fi
  done

  local sz i
  local sz=${#line}

  if [ ${sz} -eq 1 -a ${#pref} -eq 1 ] ; then
     test ${DEBUG_CONF} && voidX
     return
  fi

  for((i=0 ; i < sz ; ++i )) ; do
    test "${line:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    if [ ${isOO:-f} = t ] ; then
       # it is a value
       test ${DEBUG_CONF} && voidX
       return
    fi

    # var-name without any value
    line=$( echo "${line/% /}" | tr "[:lower:]" "[:upper:]" )
    line=${line:0:1}$( echo "${line:1}" | tr "-" "_" )
  else
    local tmp0="${line:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=${tmp0:0:1}$( echo "${tmp0:1}" | tr "-" "_" )
    line="${tmp0}""${line:i}"
  fi

# test "${pref}" = '--' && pref=
  eval ${1}=\${pref}\${line}

  test ${DEBUG_CONF} && voidX
  return
}

unsetKWL()
{
  test ${DEBUG_CONF} && voidX

  local key
  item="$*"

  key=$( echo "${item}" | tr "[:lower:]" "[:upper:]" )

  # was key already defined?
  local i
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      eval unset $key
      unset keyWordList[$i]
      break
    fi
  done

  test ${DEBUG_CONF} && voidX
  return
}

voidX()
{
  # toggle between set -x and set +x in a way that
  # restores the original setting after having been called twice

  if [ ${isSetX:-t} = t ] ; then
    test "$(set -o |grep xtrace | awk '{print $2}')" = off && return

    # first call
    isSetX=on
  fi

  # restore previous setting
  if [ ${isSetX} = off ] ; then
    set -x
    isSetX=on
  else
    set +x
    isSetX=off
  fi

  return
}

##main()
##{

# ############### main ###############
umask 002

# very specific: convert -E_SELECT or -E_LOCK into -S or -L respectively.
# Accept -E_SELECT=param, -ESELECT=param, -E SELECT=param
# Case-insensitive, and also for LOCK.

declare -a arg
prev_opt=none

for(( i=1 ; i <= $# ; ++i )) ; do
  item=${!i}
  ITEM=${item}
  tr_option ITEM $prev_opt
  prev_opt=${ITEM}

  if [ ${ITEM:0:2} = '-E' ] ; then
    if [ ${ITEM} = '-E' ] ; then
       # opt-arg is space separated
       arg[${#arg[*]}]='-E'
    elif [ ${ITEM:0:3} = '-E_' ] ; then
       # opt-arg is underscore separated
       arg[${#arg[*]}]='-E'
       arg[${#arg[*]}]="${ITEM:3}"
    else
       # opt-arg is aligned to -E
       arg[${#arg[*]}]='-E'
       arg[${#arg[*]}]="${ITEM:2}"
    fi

    j=$(( ${#arg[*]} -1 ))
    j0=$((j-1))

    if [ ${arg[j]:0:6} = 'SELECT' -o ${arg[j]:0:4} = 'LOCK' ] ; then
      # overwrite last arg, i.e. '-E'
      if [ ${arg[j]#*=} != ${arg[j]} ] ; then
         arg[j0]="-${arg[j]:0:1}"
         arg[j]="${ITEM#*=}"  # prefixed by -S or -L followed by arg
      fi
    fi

  else
    arg[${#arg[*]}]="$item"
  fi
done

if [ "${arg}" ] ; then
   set -- ${arg[*]}
fi

# stage 0: scan for configuration files etc.
while getopts :d:D:e:E:f:hmP:QqL:S:s:T:Vx-: option
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  OPTNAME=${UOPTARG%%=*}
  OPTVAL=${OPTARG#*=}

  case $option in
  e|E)  if [ ${OPTNAME} = 'CONDA_PATH' ] ; then
          setKWL CONDA_PATH=${OPTVAL}
        elif [ ${OPTNAME:0:7} = 'DEBUG_C' ] ; then
          DEBUG_CONF=t
          set -x
        elif [ ${OPTNAME} = 'PROJECT=' ] ; then
          setKWL ${OPTARG}
        elif [ ${OPTNAME} = 'QA_CONFIG' ] ; then
          localQAC=${OPTVAL}
        elif [ ${OPTNAME} = 'QA_HOME' ] ; then
          setKWL QA_HOME=${OPTVAL}
        elif [ ${OPTNAME} = 'QA_SRC' ] ; then
          setKWL QA_SRC=${OPTVAL}
        fi
        ;;
    f)  if [ -f ${OPTARG} ] ; then
          qaConf[${#qaConf[*]}]=${OPTARG##*/}
        else
          test -c "$TTY" && echo "${OPTARG}: no such file" > $TTY
          exit 1
        fi
        ;;
    h)  isHelp=t ;;
    P)  setKWL PROJECT=$OPTARG ;;
    T)  TTY=${OPTARG} ;;
    x)  set -x
        DEBUG_CONF=t
        installArgs+="--debug,"
        setKWL DEBUG_MANAGER
        DEBUG_CONF=t
        ;;
    -)  if [ "$OPTNAME" = HELP ] ; then
           isHelp=t

        elif [ "${OPTNAME}" = DEBUG ] ; then
          set -x
          installArgs+="--debug,"
          setKWL DEBUG_MANAGER
          DEBUG_CONF=t

        elif [ "${OPTNAME}" = EXAMPLE ] ; then
          setKWL QA_EXAMPLE=t

        elif [ ${OPTNAME} = CONFIG_FILE -o ${OPTNAME} = CF ] ; then
          installArgs+="--cf=${OPTVAL},"

        elif [ "${OPTNAME}" = HOME -o "${OPTNAME}" = QA_HOME ] ; then
           setKWL QA_HOME=${OPTVAL}

        elif [ "${OPTNAME}" = WORK ] ; then
           setKWL QA_RESULTS=${OPTVAL}
        fi
        ;;
   \?)  ;;
  esac
done

if [ ${isHelp:-f} = t ] ; then
  . $QA_SRC/scripts/qa-help
fi

if [ ${isConfigFile} ] ; then
  if [ ! "${CONFIG_FILE_LOCATION}" ] ; then
    if [ ${QA_HOME} ] ; then
      setKWL CONFIG_FILE=${QA_HOME}/.qa-dkrz/config.txt
    else
      echo "option --lcf requires provision of --qa-home"
      exit 1
    fi
  fi
else
  setKWL CONFIG_FILE=${HOME}/.qa-dkrz/config.txt
fi

# may be overwritten by configuration file or command-line
setDefaults

# get valid configuration files corresponding to the priority list0
test "${localQAC}"  && qaConf[${#qaConf[*]}]=${localQAC}
findQAConfSeq ${qaConf[*]}

# construct a comma-sep-list, just for the log-file
if [ ${#qaConfFileSeq[*]} -gt 0 ] ; then
  QA_CONFS="${qaConfFileSeq[*]}"
  QA_CONFS="${QA_CONFS// /,}"

  setKWL TASK=${qaConfFileSeq[0]##*/}
fi

# proceed from low to high precedence
for(( i=${#qaConfFileSeq[*]}-1 ; i > -1 ; --i )) ; do
  parseConfigurationFile ${qaConfFileSeq[i]}
done

# command-line overwrites configuration file assignments
comLine=( $* ) # for e-mail and initSession

test ${QA_CONFS} && setKWL QA_CONF=${QA_CONFS}

# look for multiple occurrences; pass command-line notes as parameter
for(( i=0 ; i < ${#comLine[*]} ; ++i )) ; do
  cL=${comLine[i]}
  test ! ${cL} && continue

  tr_option cL

  if findStr ${cL} NOTE ; then
    comLineNotes[${#comLineNotes[*]}]="${cL}"
  fi
done

getMultiLists ${comLineNotes[*]}

# Note: option -T is used internally, when the qa-DKRZ
#       executes the qaConfiguration script.
set -f

# stage1
unset OPTIND
while getopts d:D:e:E:f:hmP:QqL:S:s:T:x-: option
do
  UOPTARG="${OPTARG}"
  tr_option UOPTARG

  OPTNAME=${UOPTARG%%=*}

  OPTVAL=
  test "${OPTNAME}" != "${UOPTARG}" && OPTVAL=${OPTARG#*=}

  case $option in
    d|D) # disable previously enabled options
         unsetKWL ${OPTNAME} ;;
    e|E) # Enable features or set parameters
         test ${OPTNAME:0:7} != 'DEBUG_C' && parseOPTARG ${OPTARG}
         ;;
    f)  # already done
        ;;
    h)  # already done
        exit 1  ;;
    L)  sel_lock L ${OPTARG}
        set +f
        ;;
    m)  setKWL SIMPLE_STATUS_LINE=t ;;
    P)  setKWL PROJECT=$OPTARG ;;
    Q)  setKWL NO_STATUS=t ;;
    q)  setKWL QUIET=t ;;
    S)  sl_args=( ${OPTARG//,/} )
        ;;
    s)  setKWL SESSION_DATE=${OPTARG} ;;
    T)  # already caught
        ;;
    x)  setKWL DEBUG_MANAGER=t
        setKWL DEBUG_EXECUTOR=t
        ;;  # already done for this script
    -)  if [ "${UOPTARG:0:7}" = AUTO_UP ] ; then
          . ${QA_SRC}/scripts/parseConfigFile AUTO_UPDATE=${OPTVAL}

        elif [ "${OPTNAME:0:5}" = DEBUG ] ; then
          : # done before

        elif [ "${OPTNAME}" = EXAMPLE ] ; then
          : # done before

        elif [ "${OPTNAME}" = HOME ] ; then
          : # done before

        elif [ "${OPTNAME}" = INSTALL ] ; then
          opts=( ${OPTVAL//,/ } )

          for opt in ${opts[*]} ; do
             tr_option opt

             for(( i=0 ; i < ${#definedProjects[*]} ; ++i )) ; do
                if [ "${opt}" = ${definedProjects[i]} ] ; then
                   setKWL PROJECT=${opt}
                   continue 2
                fi
             done

             test ${opt:0:2} != '--' && opt='--'"${opt}"
             installArgs+="${opt},"
          done

          test ${installArgs//--up/} = ${installArgs} && installArgs+="--up,"
          setKWL UPDATE=t

        elif [ "${OPTNAME}" = NET ] ; then
          installArgs+="--${OPTARG},"

        elif [ "${OPTARG:0:2}" = pb ] ; then
          if [ ${OPTARG} = ${OPTVAL} ] ; then
            setKWL PROGRESS_BAR=t
          else
            setKWL PROGRESS_BAR=${OPTVAL}  # file to write to
          fi

        elif [ "${OPTNAME}" = PROJECT_AS ] ; then
          setKWL PROJECT_AS=${OPTVAL}

        elif [ "${OPTNAME}" = SET_DEFAULT_PROJECT ] ; then
          installArgs+="--set_default_project=${OPTVAL},"

        elif [ "${OPTNAME:0:2}" = UP ] ; then
          tr_option OPTVAL
          if [ "${OPTVAL}" = NO -o "${OPTVAL:0:1}" = F -o "${OPTVAL:0:1}" = D ] ; then
            OPTVAL=f
          else
            OPTVAL=t
          fi

          setKWL UPDATE=${OPTVAL}
          installArgs+="--up=${OPTVAL},"

        elif [ "${OPTNAME:0:4}" = WORK ] ; then
          : # done before

        fi
        ;;
   \?)  #  . $QA_SRC/scripts/qa-help
        exit 1;;
  esac
done

test ${installArgs} && setKWL INSTALL_ARGS="--install=${installArgs}"

shift $(( $OPTIND - 1 ))

# for downward compatibility
test ${QA_DATA_ROOT} && setKWL QA_RESULTS=${QA_DATA_ROOT}
test ${DATA_ROOT_FS} && setKWL PROJECT_DATA=${DATA_ROOT_FS}

if [ $# -gt 0 ] ; then
  # any valid files specified on the command-line
  for f in $* ; do
     if [ -f ${f} ] ; then
       if [ ${f:0:1} = '/' ] ; then
          sl_args[${#sl_args[*]}]=${f}
       else
          # just a (relative) filename on the command-line
          sl_args[${#sl_args[*]}]=$(pwd)/${f}
       fi
     fi

  done

#  sl_args=( ${sl_args[*]} ${*//,/ } )
fi

set +f

if [ ${PROJECT} ] ; then
  test ! ${PROJECT_AS} && setKWL PROJECT_AS=$PROJECT

  # almost everything is done here
  loadSetting
fi

output

##}
